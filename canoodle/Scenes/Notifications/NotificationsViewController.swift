//
//  NotificationsViewController.swift
//  MadCollab
//
//  Created by Appineers India on 28/04/20.
//  Copyright (c) 2020 hb. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CRRefresh


protocol NotificationsDisplayLogic: class
{
    func didReceiveNotificationsResponse(response: [Notification.ViewModel]?, message: String, successCode: String)
    func didReceiveDeleteNotificationResponse(message: String, successCode: String)
}

class NotificationsViewController: UIViewController
{
    @IBOutlet weak var notificationsTableView: UITableView!
    @IBOutlet weak var watermarkView: UIView!
    @IBOutlet weak var segmentedControl: UISegmentedControl!

    
  var interactor: NotificationsBusinessLogic?
  var router: (NSObjectProtocol & NotificationsRoutingLogic & NotificationsDataPassing)?

    var notificationsList:[Notification.ViewModel] = []
    var filteredList:[Notification.ViewModel] = []

    var selectedRowIndex: Int = 0

  // MARK: Object lifecycle
  
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
  {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder)
  {
    super.init(coder: aDecoder)
    setup()
  }
  
    
    // MARK: Class Instance
    class func instance() -> NotificationsViewController? {
        return StoryBoard.Notifications.board.instantiateViewController(withIdentifier: AppClass.NotificationsVC.rawValue) as? NotificationsViewController
    }
    
  // MARK: Setup
  
  private func setup()
  {
    let viewController = self
    let interactor = NotificationsInteractor()
    let presenter = NotificationsPresenter()
    let router = NotificationsRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }
  
  // MARK: Routing
  
  override func prepare(for segue: UIStoryboardSegue, sender: Any?)
  {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }
  
  // MARK: View lifecycle
  
  override func viewDidLoad()
  {
    super.viewDidLoad()
    self.title = "Notifications"
    segmentedControl.layer.borderColor = AppConstants.appColor?.cgColor
    segmentedControl.layer.borderWidth = 1.0
    segmentedControl.backgroundColor = UIColor.white
    segmentedControl.setTitleTextAttributes([NSAttributedString.Key.foregroundColor :  UIColor.white ,NSAttributedString.Key.font : UIFont.systemFont(ofSize: 12.0)], for: UIControl.State.selected)
    segmentedControl.setTitleTextAttributes([NSAttributedString.Key.foregroundColor :  AppConstants.appColor, NSAttributedString.Key.font : UIFont.systemFont(ofSize: 12.0)], for: UIControl.State.normal)
  }
    
    override func viewDidAppear(_ animated: Bool) {
        //UserDefaultsManager.notificationCount = 0
        self.addAnayltics(analyticsParameterItemID: "id-notificationsscreen", analyticsParameterItemName: "view_notificationsscreen", analyticsParameterContentType: "view_notificationsscreen")
        notificationsTableView.cr.addHeadRefresh(animator: FastAnimator()) { [weak self] in
            /// start refresh
            self!.getNotifications()
            DispatchQueue.main.asyncAfter(deadline: .now() + 60, execute: {
                /// Stop refresh when your job finished, it will reset refresh footer if completion is true
                self?.notificationsTableView.cr.endHeaderRefresh()
            })
        }
        /// manual refresh
        notificationsTableView.cr.beginHeaderRefresh()
    }
  
  // MARK: Do something
  
  func getNotifications()
  {
    interactor?.getNotifications()
  }
    
    func clearAllNotifications() {
        notificationsList.forEach { notification in
            let request = Notification.Request(notificationId: notification.notificationId)
            interactor?.deleteNotification(request: request)
        }
    }
    
    func filterList() {
        var filteredArray:[Notification.ViewModel] = []
        notificationsList.forEach {
            let notification:Notification.ViewModel = $0
            switch segmentedControl.selectedSegmentIndex {
            case 0:
                if(UserDefaultsManager.getLoggedUserDetails()?.premiumStatus?.booleanStatus() == true) {
                    if(notification.notificationType == "Match" || notification.notificationType == "Like") {
                        filteredArray.append(notification)
                    }
                } else {
                    if(notification.notificationType == "Match") {
                        filteredArray.append(notification)
                    }
                }
            case 1:
                if(notification.notificationType == "Message") {
                    filteredArray.append(notification)
                }
            default:
                print("")
            }
        }
        filteredList = filteredArray
        notificationsTableView.reloadData()
    }
    
    func filterBlockedUsers() {
        var filteredArray:[Notification.ViewModel] = []
        notificationsList.forEach {
            let notification:Notification.ViewModel = $0
            if(notification.connectionStatus != "Block") {
                filteredArray.append(notification)
            }
        }
        notificationsList = filteredArray
    }
    
    @IBAction func segmentChanged() {
        filterList()
    }
    
    func deleteNotification(notification: Notification.ViewModel)
    {
        let request = Notification.Request(notificationId: notification.notificationId)
        interactor?.deleteNotification(request: request)
    }

    
    func displayDeleteNotificationResponse(response: Bool)
    {
        if(response == true) {
            self.showTopMessage(message: "Notification deleted successfully", type: .Success)
            notificationsList.remove(at: selectedRowIndex)
            notificationsTableView.deleteRows(at: [IndexPath.init(row: selectedRowIndex, section: 0)], with: .fade)
            if(notificationsList.count == 0) {
                notificationsTableView.isHidden = true
                watermarkView.isHidden = false
                self.navigationItem.rightBarButtonItem = nil
            }
        }
        else {
            self.showTopMessage(message: "Error deleting notification. Please try again", type: .Error)
        }
    }
    
    @IBAction func btnClearAction(_ sender: UIBarButtonItem) {
        self.displayAlert(msg: "Are you sure you want to clear all notifications?", ok: "Yes", cancel: "No", okAction: {
            self.clearAllNotifications()
        }, cancelAction: nil)
    }
}


// UITableView Delegate methods
extension NotificationsViewController: UITableViewDelegate, UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if(filteredList.count == 0) {
            notificationsTableView.isHidden = true
            watermarkView.isHidden = false
        } else {
            notificationsTableView.isHidden = false
            watermarkView.isHidden = true
        }
        return filteredList.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        var cell: NotificationsViewCell! = tableView.dequeueReusableCell(withIdentifier: "NotificationsViewCell") as? NotificationsViewCell
        
        if cell == nil {
            tableView.register(UINib(nibName: "NotificationsViewCell", bundle: nil), forCellReuseIdentifier: "NotificationsViewCell")
            cell = tableView.dequeueReusableCell(withIdentifier: "NotificationsViewCell") as? NotificationsViewCell
        }
        cell.delegate = self
        cell.setCellData(notification: filteredList[indexPath.row])
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let notification: Notification.ViewModel = notificationsList[indexPath.row]
        switch notification.notificationType {
        case "Like", "Match":
            if let userProfileVC = UserProfileViewController.instance() {
                userProfileVC.userId = notification.notificationUserId!
                self.navigationController?.pushViewController(userProfileVC, animated: true)
            }
        case "Message":
            if let chatVC = ChatViewController.instance() {
                let connection = Connection.ViewModel.init(dictionary: ["user_id": notification.notificationUserId!, "user_name": notification.userName!, "user_image": notification.userImage!])
                chatVC.setConnection(connection: connection!)
                self.navigationController?.pushViewController(chatVC, animated: true)
            }
        default:
            if let userProfileVC = UserProfileViewController.instance() {
                userProfileVC.userId = notification.notificationUserId!
                self.navigationController?.pushViewController(userProfileVC, animated: true)
            }
        }
    }
    
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            deleteNotification(notification: filteredList[indexPath.row])
        }
    }
}

//NotificationsViewCellProtocol methods
extension NotificationsViewController: NotificationsViewCellProtocol {
    
    func messageUser(notification: Notification.ViewModel) {
        if let chatVC = ChatViewController.instance() {
            let connection = Connection.ViewModel.init(dictionary: ["user_id": notification.notificationUserId!, "user_name": notification.userName!, "user_image": notification.userImage!])
            chatVC.setConnection(connection: connection!)
            self.navigationController?.pushViewController(chatVC, animated: true)
        }
    }
    
    func showUser(notification: Notification.ViewModel) {
        if let userProfileVC = UserProfileViewController.instance() {
            userProfileVC.userId = notification.notificationUserId!
            self.navigationController?.pushViewController(userProfileVC, animated: true)
        }
    }
    
    func showProfileImage(userImage: String) {
        if let customPopUp = ImageDetailsViewController.instance() {
            customPopUp.imgStr = userImage ?? ""
            self.present(customPopUp, animated: true, completion: nil)
        }
    }
}

extension NotificationsViewController: NotificationsDisplayLogic {
    func didReceiveNotificationsResponse(response: [Notification.ViewModel]?, message: String, successCode: String) {
        self.notificationsTableView.cr.endHeaderRefresh()
        if successCode == "1" {
            print(message)
            if let data = response {
                notificationsList.removeAll()
                self.notificationsList.append(contentsOf: data)
                filterBlockedUsers()
                filterList()
                if(notificationsList.count == 0) {
                    self.navigationItem.rightBarButtonItem = nil
                } else {
                    let clearButton = UIBarButtonItem(title: "Clear", style: .plain, target: self, action: #selector(btnClearAction))
                    clearButton.tintColor = UIColor.white
                    self.navigationItem.rightBarButtonItem = clearButton
                }
            }
        } else {
            //self.showTopMessage(message: message, type: .Error)
            notificationsList.removeAll()
            notificationsTableView.reloadData()
            self.navigationItem.rightBarButtonItem = nil
        }
    }
    
    func didReceiveDeleteNotificationResponse(message: String, successCode: String) {
        if successCode == "1" {
            self.showTopMessage(message: message, type: .Success)
            getNotifications()
        } else {
            self.showTopMessage(message: message, type: .Error)
        }
    }
}
